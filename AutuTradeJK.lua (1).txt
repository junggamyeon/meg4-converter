repeat task.wait() until game:IsLoaded()

local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")

local LP = Players.LocalPlayer
repeat task.wait() until LP
repeat task.wait() until LP:FindFirstChild("PlayerGui")
task.wait(1)

local Config = getgenv().Config or {}
local CHANGE_MAIN_AT = tonumber(Config["Change Acc Main When Has Sticker"] or 0)

local StickerTypes = require(RS:WaitForChild("Stickers"):WaitForChild("StickerTypes"))
local ClientStatCache = require(RS:WaitForChild("ClientStatCache"))
local EventsApi = require(RS:WaitForChild("Events"))

local function normalize(str)
    return tostring(str):lower():gsub("%s+", "")
end

local MAIN_LIST = {}
local function pushMain(v)
    if not v then return end
    MAIN_LIST[#MAIN_LIST + 1] = normalize(v)
end

if type(Config["Main Account"]) == "table" then
    for _, v in ipairs(Config["Main Account"]) do pushMain(v) end
else
    pushMain(Config["Main Account"])
end

local function isMainPlayer(p)
    if not p then return false end
    local uid = normalize(p.UserId)
    local name = normalize(p.Name)
    local dname = normalize(p.DisplayName)
    for _, main in ipairs(MAIN_LIST) do
        if uid == main or name == main or dname == main then
            return true
        end
    end
    return false
end

local function isMain()
    return isMainPlayer(LP)
end

local function findMain()
    for _, p in ipairs(Players:GetPlayers()) do
        if isMainPlayer(p) then
            return p
        end
    end
end

local WANT_SET = {}
do
    local t = Config["Sticker Trade"]
    if type(t) == "table" then
        for _, v in ipairs(t) do
            WANT_SET[normalize(v)] = true
        end
    elseif t ~= nil then
        WANT_SET[normalize(t)] = true
    end
end
local HAS_WANT = next(WANT_SET) ~= nil

local STICKER_ID_MAP = {}
do
    local types = StickerTypes and StickerTypes.Types
    if type(types) == "table" then
        for name, def in pairs(types) do
            if def and def.ID then
                STICKER_ID_MAP[def.ID] = name
            end
        end
    end
end

local function getStickerNameById(typeId)
    return STICKER_ID_MAP[typeId] or "Unknown"
end

local function getCache()
    local ok, cache = pcall(function()
        return ClientStatCache:Get()
    end)
    return ok and cache or nil
end

local function getBook(cache)
    cache = cache or getCache()
    return cache and cache.Stickers and cache.Stickers.Book or nil
end

local function getInbox(cache)
    cache = cache or getCache()
    return cache and cache.Stickers and cache.Stickers.Inbox or nil
end

local function hasWantedSticker()
    if not HAS_WANT then return false end
    local cache = getCache()
    if not cache or not cache.Stickers then return false end

    local function scan(list)
        if type(list) ~= "table" then return false end
        for _, data in ipairs(list) do
            local typeId = data.TypeID or data[3]
            if typeId then
                local name = getStickerNameById(typeId)
                if WANT_SET[normalize(name)] then
                    return true
                end
            end
        end
        return false
    end

    return scan(cache.Stickers.Book) or scan(cache.Stickers.Inbox)
end

local function getValidStickers(book)
    local list = {}
    if not HAS_WANT or type(book) ~= "table" then return list end

    for _, data in ipairs(book) do
        local slot1, slot2, slot3, slot4 = data[1], data[2], data[3], data[4]
        local typeId = data.TypeID or slot3
        if typeId then
            local name = getStickerNameById(typeId)
            if WANT_SET[normalize(name)] then
                list[#list + 1] = { Name = name, File = {slot1, slot2, slot3, slot4} }
            end
        end
    end

    return list
end

local function getStickerSlotCount()
    local book = getBook()
    if type(book) ~= "table" then return 0 end
    return #book
end

local RemoteRoot
local function resolveRemoteRoot()
    if RemoteRoot and RemoteRoot.Parent then return RemoteRoot end
    RemoteRoot = RS:FindFirstChild("Events", true)
    if RemoteRoot and RemoteRoot:IsA("Folder") then return RemoteRoot end

    RemoteRoot = RS:FindFirstChild("Remotes", true)
    if RemoteRoot and RemoteRoot:IsA("Folder") then return RemoteRoot end

    RemoteRoot = RS:FindFirstChild("RemoteEvents", true)
    if RemoteRoot and RemoteRoot:IsA("Folder") then return RemoteRoot end

    RemoteRoot = nil
    return nil
end

local function getRemote(name)
    local root = resolveRemoteRoot()
    return root and root:FindFirstChild(name, true) or nil
end

local function sendRemote(remoteName, ...)
    local r = getRemote(remoteName)
    if not r then return false end
    if r:IsA("RemoteFunction") then
        local ok = pcall(function()
            r:InvokeServer(...)
        end)
        return ok
    elseif r:IsA("RemoteEvent") then
        local ok = pcall(function()
            r:FireServer(...)
        end)
        return ok
    end
    return false
end

local LAST_CLICK = 0
local CLICK_DELAY = 0.15

local function fireConnections(signal)
    local ok, conns = pcall(function()
        return getconnections(signal)
    end)
    if not ok or not conns then return false end

    for _, c in ipairs(conns) do
        if typeof(c.Function) == "function" then
            local success = pcall(c.Function)
            if success then return true end
        end
    end
    return false
end

local function smartGuiClick(btn)
    if not btn then return false end
    if not btn.Visible or not btn.Active then return false end
    if tick() - LAST_CLICK < CLICK_DELAY then return false end

    LAST_CLICK = tick()

    if btn:IsA("GuiButton") then
        if fireConnections(btn.Activated) then return true end
        if fireConnections(btn.MouseButton1Click) then return true end
        pcall(function() btn:Activate() end)
        return true
    end
    return false
end

local function tradeAnchor()
    local pg = LP:FindFirstChild("PlayerGui")
    if not pg then return nil end
    for _, v in ipairs(pg:GetDescendants()) do
        if v.Name == "TradeAnchorFrame" then
            return v
        end
    end
end

local function waitForTradeAnchor(timeout)
    local t0 = tick()
    while true do
        local anchor = tradeAnchor()
        if anchor then return anchor end
        if timeout and tick() - t0 > timeout then return nil end
        task.wait(0.25)
    end
end

local function completed(tag)
    pcall(function()
        writefile(LP.Name .. ".txt", tag or "Completed-DaTrade")
    end)
end

local LAST_SESSION_ID = nil
local SESSION_LOCKED = false

EventsApi.ClientListen("TradeUpdateInfo", function(info)
    if not info or not info.SessionID then return end
    if SESSION_LOCKED then return end
    if tostring(info.State or ""):lower() ~= "ongoing" then return end
    LAST_SESSION_ID = tonumber(info.SessionID)
    SESSION_LOCKED = true
end)

local function addSticker(sessionId, file)
    return sendRemote("TradePlayerAddItem", sessionId, {
        Category = "Sticker",
        File = { [1]=file[1], [2]=file[2], [3]=file[3], [4]=file[4] }
    })
end

local function acceptTrade(sessionId, altId, mainId, packs)
    return sendRemote("TradePlayerAccept", sessionId, {
        [tostring(altId)] = packs,
        [tostring(mainId)] = {}
    })
end

local function startMain()
    local firstOpenTime = nil

    EventsApi.ClientListen("TradeInformOfRequest", function(_, sessionId)
        task.wait(0.1)
        EventsApi.ClientCall("TradePlayerConfirmStart", sessionId)
    end)

    while true do
        local anchor = tradeAnchor()

        if anchor then
            if not firstOpenTime then firstOpenTime = tick() end
            if tick() - firstOpenTime >= 1.2 then
                local ok, btn = pcall(function()
                    return anchor.TradeFrame.ButtonAccept.ButtonTop
                end)
                if ok and btn and btn.Visible then
                    smartGuiClick(btn)
                end
            end
        else
            firstOpenTime = nil
        end

        if CHANGE_MAIN_AT > 0 and not WROTE_MAIN_FILE then
            if getStickerSlotCount() >= CHANGE_MAIN_AT then
                WROTE_MAIN_FILE = true
                completed("Completed-MainAutoTrade")
                task.wait(0.8)
                LP:Kick("[Overdex] - Trade done!")
                return
            end
        end

        task.wait(2.5)
    end
end

local ALT_DONE = false
local function startAlt()
    if not HAS_WANT then
        completed("Completed-NoStickerConfig")
        task.wait(0.8)
        LP:Kick("[Overdex] - No Sticker Trade config!")
        return
    end

    local main
    repeat
        main = findMain()
        task.wait(1)
    until main

    while true do
        local cache = getCache()
        local book = cache and cache.Stickers and cache.Stickers.Book or nil
        local valid = getValidStickers(book)

        if #valid == 0 then
            if not ALT_DONE then
                ALT_DONE = true
                task.wait(2)
                if not hasWantedSticker() then
                    task.wait(1)
                    if not hasWantedSticker() then
                        completed("Completed-DaTrade")
                        task.wait(0.8)
                        LP:Kick("[Overdex] - Trade done!")
                        return
                    end
                end
            end
            ALT_DONE = false
            task.wait(1)
            continue
        end

        if not tradeAnchor() and SESSION_LOCKED then
            SESSION_LOCKED = false
            LAST_SESSION_ID = nil
        end

        if not tradeAnchor() then
            sendRemote("TradePlayerRequestStart", main.UserId)
        end

        local anchor = waitForTradeAnchor(30)
        if not anchor then
            task.wait(2)
            continue
        end

        local t0 = tick()
        while tradeAnchor() and not LAST_SESSION_ID do
            if tick() - t0 > 15 then break end
            task.wait(0.1)
        end

        if not LAST_SESSION_ID then
            SESSION_LOCKED = false
            task.wait(2)
            continue
        end

        local sessionId = LAST_SESSION_ID
        local packs = {}
        local idx = 1

        for _, sticker in ipairs(valid) do
            while not tradeAnchor() do
                SESSION_LOCKED = false
                LAST_SESSION_ID = nil
                task.wait(1)
                main = findMain()
                if main then
                    sendRemote("TradePlayerRequestStart", main.UserId)
                end
            end

            addSticker(sessionId, sticker.File)

            packs[idx] = {
                Pack = {
                    File = { [1]=sticker.File[1], [2]=sticker.File[2], [3]=sticker.File[3], [4]=sticker.File[4] },
                    Category = "Sticker"
                },
                Validated = false,
                Owner = tostring(LP.UserId),
                IDString = "U" .. LP.UserId .. ":Sticker:" .. table.concat(sticker.File, "-"),
                ClientSide = true
            }

            idx += 1
            task.wait(0.2)
        end

        if tradeAnchor() and #packs > 0 then
            task.wait(0.5)
            acceptTrade(sessionId, LP.UserId, main.UserId, packs)
        end

        repeat task.wait(0.5) until not tradeAnchor()

        SESSION_LOCKED = false
        LAST_SESSION_ID = nil
        task.wait(2)
    end
end

local function runTrashDiscardLoop()
    task.spawn(function()
        while true do
            if Config["Discard trash sticker"] then
                local cache = getCache()
                local book = cache and cache.Stickers and cache.Stickers.Book or nil
                if type(book) == "table" then
                    for _, data in ipairs(book) do
                        local slot1, slot2, slot3, slot4 = data[1], data[2], data[3], data[4]
                        local typeId = data.TypeID or slot3
                        local name = getStickerNameById(typeId)
                        local keep = WANT_SET[normalize(name)] == true

                        if not keep then
                            sendRemote("StickerDiscard", {
                                [1]=slot1, [2]=slot2, [3]=slot3, [4]=slot4
                            }, false)
                            task.wait(0.3)
                        end
                    end
                end
            end
            task.wait(5)
        end
    end)
end

local function runAutoClaimStickerInbox()
    task.spawn(function()
        while true do
            if Config["Auto Claim Sticker Inbox"] then
                local cache = getCache()
                local inbox = cache and cache.Stickers and cache.Stickers.Inbox or nil
                if type(inbox) == "table" and #inbox > 0 then
                    local book = cache.Stickers.Book or {}
                    local usedSlots = {}
                    for _, data in ipairs(book) do
                        local slot = data[4] or data.Slot
                        if slot then usedSlots[slot] = true end
                    end

                    local function findEmptySlot()
                        local i = 1
                        while usedSlots[i] do i += 1 end
                        usedSlots[i] = true
                        return i
                    end

                    for i = #inbox, 1, -1 do
                        local data = inbox[i]
                        local slot1, slot2, slot3 = data[1], data[2], data[3]
                        local emptySlot = findEmptySlot()

                        sendRemote("StickerClaimFromInbox", {
                            [1]=slot1, [2]=slot2, [3]=slot3, [4]=emptySlot
                        }, false)

                        task.wait(0.4)
                    end
                end
            end
            task.wait(5)
        end
    end)
end

task.spawn(function()
    if isMain() then
        startMain()
    else
        startAlt()
    end
end)

runTrashDiscardLoop()
runAutoClaimStickerInbox()
